## Doing things with data frames
Let’s go back to our Australian athletes: 

```{r read-athletes, echo=F}
my_url <- "http://ritsokiguess.site/datafiles/ais.txt"
athletes <- read_tsv(my_url)
```

\footnotesize

```{r}
athletes
```
\normalsize

## Choosing a column

```{r}
athletes %>% select(Sport)
```

## Choosing several columns

```{r}
athletes %>% select(Sport, Hg, BMI)
```

## Choosing consecutive columns

```{r}
athletes %>% select(Sex:WCC)
```

## Choosing all-but some columns

```{r}
athletes %>% select(-(RCC:LBM))
```

## Select-helpers
Other ways to select columns: those whose name:

- `starts_with` something
- `ends_with` something
- `contains` something
- `matches` a “regular expression”
- `everything()` select all the columns

## Columns whose names begin with S 

```{r}
athletes %>% select(starts_with("S"))
```

## Columns whose names end with C

either uppercase or lowercase:

```{r}
athletes %>% select(ends_with("c"))
```

## Case-sensitive

This works with any of the select-helpers:

```{r}
athletes %>% select(ends_with("C", ignore.case=F))
```


## Column names containing letter R

```{r}
athletes %>% select(contains("r"))
```

## Exactly two characters, ending with T

In regular expression terms, this is `^.t$`:

- `^` means “start of text”
- `.` means “exactly one character, but could be anything”
- `$` means “end of text”.
```{r}
athletes %>% select(matches("^.t$"))
```

## Choosing columns by property

- Use `where` as with summarizing several columns
- eg, to choose text columns:

```{r}
athletes %>% select(where(is.character))
```


## Choosing rows by number 

```{r}
athletes %>% slice(16:25)
```




## Non-consecutive rows 

```{r}
athletes %>% 
  slice(10,13,17,42)
```

## A random sample of rows

```{r}
athletes %>% slice_sample(n=8)
```

## Rows for which something is true

\footnotesize
```{r}
athletes %>% filter(Sport == "Tennis")
```
\normalsize

## More complicated selections

```{r}
athletes %>% filter(Sport == "Tennis", RCC < 5)
```

## Another way to do "and"

```{r}
athletes %>% filter(Sport == "Tennis") %>% 
  filter(RCC < 5)
```


## Either/Or

```{r}
athletes %>% filter(Sport == "Tennis" | RCC > 5)
```

## Sorting into order

```{r}
athletes %>% arrange(RCC)
```

## Breaking ties by another variable

```{r}
athletes %>% arrange(RCC, BMI)
```

## Descending order

```{r}
athletes %>% arrange(desc(BMI))
```

## “The top ones”


```{r}
athletes %>%
  arrange(desc(Wt)) %>%
  slice(1:7) %>%
  select(Sport, Wt)
```

## Another way

```{r}
athletes %>% 
  slice_max(order_by = Wt, n=7) %>% 
  select(Sport, Wt)
```


## Create new variables from old ones

```{r new-from-old}
athletes %>%
  mutate(wt_lb = Wt * 2.2) %>%
  select(Sport, Sex, Wt, wt_lb) %>% 
  arrange(Wt)
```

## Turning the result into a number
Output is always data frame unless you explicitly turn it into something
else, eg. the weight of the heaviest athlete, as a number:

```{r to-number}
athletes %>% arrange(desc(Wt)) %>% pluck("Wt", 1)
```

Or the 20 heaviest weights in descending order:


```{r}
athletes %>%
  arrange(desc(Wt)) %>%
  slice(1:20) %>%
  pluck("Wt")
```

## Another way to do the last one

```{r}
athletes %>%
  arrange(desc(Wt)) %>%
  slice(1:20) %>%
  pull("Wt")
```

`pull` grabs the column you name *as a vector* (of whatever it contains).

## To find the mean height of the women athletes
Two ways:

\small
```{r}
athletes %>% group_by(Sex) %>% summarize(m = mean(Ht))
```

```{r}
athletes %>%
  filter(Sex == "female") %>%
  summarize(m = mean(Ht))
```

\normalsize

## Summary of data selection/arrangement "verbs"

 \begin{tabular}{lp{0.7\textwidth}}
    Verb & Purpose\\
    \hline
    \texttt{select} & Choose columns\\
    \texttt{print} & Display non-default \# of rows/columns \\
    \texttt{slice} & Choose rows by number\\
    \texttt{sample\_n} & Choose random rows\\ 
    \texttt{filter} & Choose rows satisfying conditions \\
    \texttt{arrange}& Sort in order by column(s) \\
    \texttt{mutate} & Create new variables\\
    \texttt{group\_by} & Create groups to summarize by\\
    \texttt{summarize} & Calculate summary statistics (by groups if defined)\\
    \texttt{pluck} & Extract items from data frame\\
    \texttt{pull} & Extract a single column from a data frame as a vector\\
    \hline
  \end{tabular}
  
  
## Looking things up in another data frame

- Suppose you are working in the nails department of a hardware store and you find that you have sold these items:

```{r, message=FALSE}
my_url <- "http://ritsokiguess.site/datafiles/nail_sales.csv"
sales <- read_csv(my_url)
sales
```


## Product descriptions and prices

- but you don't remember what these product codes are, and you would like to know the total revenue from these sales.

- Fortunately you found a list of product descriptions and prices:

\small

```{r, message=FALSE}
my_url <- "http://ritsokiguess.site/datafiles/nail_desc.csv"
desc <- read_csv(my_url)
desc
```

\normalsize

## The lookup

- How do you "look up" the product codes to find the product descriptions and prices?
- `left_join`.

```{r}
sales %>% left_join(desc)
```

## What we have

- this looks up all the rows in the *first* dataframe that are also in the *second*. 
- by default matches all columns with same name in two dataframes (`product_code` here)
- get *all* columns in *both* dataframes. The rows are the ones for that `product_code`.

So now can work out how much the total revenue was:

```{r}
sales %>% left_join(desc) %>% 
  mutate(product_revenue = sales*price) %>% 
  summarize(total_revenue = sum(product_revenue))
```


## More comments

- if any product codes are not matched, you get NA in the added columns
- anything in the *second* dataframe that was not in the first does not appear (here, any products that were not sold)
- other variations (examples follow):
  - if there are two columns with the same name in the two dataframes, and you only want to match on one, use `by` with one column name
  - if the columns you want to look up have different names in the two dataframes, use `by` with a "named list"

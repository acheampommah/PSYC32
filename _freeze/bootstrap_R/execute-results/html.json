{
  "hash": "b39d3bfbe34481136f1fea8772965337",
  "result": {
    "markdown": "---\ntitle: \"Bootstrap for sampling distribution of sample mean\"\n---\n\n\n\n## Assessing assumptions\n\n- Our $t$-tests assume normality of variable being tested\n- but, Central Limit Theorem says that normality matters less if sample is \"large\"\n- in practice \"approximate normality\" is enough, but how do we assess whether what we have is normal enough?\n- so far, use histogram/boxplot and make a call, allowing for sample size.\n\n## What actually has to be normal\n\n- is: **sampling distribution of sample mean**\n- the distribution of sample mean over *all possible samples*\n- but we only have *one* sample!\n- Idea: assume our sample is representative of the population, and draw samples from our sample (!), with replacement.\n- This gives an idea of what different samples from the population might look like.\n- Called *bootstrap*, after expression \"to pull yourself up by your own bootstraps\".\n\n## Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n## Blue Jays attendances\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\njays$attendance\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 48414 17264 15086 14433 21397 34743 44794 14184 15606 18581 19217 21519\n[13] 21312 30430 42917 42419 29306 15062 16402 19014 21195 33086 37929 15168\n[25] 17276\n```\n:::\n:::\n\n\n- A bootstrap sample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- sample(jays$attendance, replace = TRUE)\ns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 21195 34743 21312 44794 16402 19014 34743 21195 17264 18581 19014 19217\n[13] 34743 19217 14433 15062 16402 15062 34743 15062 15086 15168 15086 48414\n[25] 30430\n```\n:::\n:::\n\n\n## Getting mean of bootstrap sample\n\n- A bootstrap sample is same size as original, but contains repeated values (eg. 15062) and missing ones (42917).\n- We need the mean of our bootstrap sample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 23055.28\n```\n:::\n:::\n\n\n- This is a little different from the mean of our actual sample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(jays$attendance)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25070.16\n```\n:::\n:::\n\n\n- Want a sense of how the sample mean might vary, if we were able to take repeated samples from our population.\n- Idea: take lots of *bootstrap* samples, and see how *their* sample means vary.\n\n## Setting up bootstrap sampling\n\n- Begin by setting up a dataframe that contains a row for each bootstrap sample. I usually call this column `sim`. Do just 4 to get the idea:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(sim = 1:4)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"sim\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\"},{\"1\":\"2\"},{\"1\":\"3\"},{\"1\":\"4\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Drawing the bootstrap samples\n\n- Then set up to work one row at a time, and draw a bootstrap sample of the attendances in each row:\n\n\\small\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(sim = 1:4) %>% \n  rowwise() %>% \n  mutate(sample = list(sample(jays$attendance, replace = TRUE)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"sim\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"sample\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"<dbl [25]>\"},{\"1\":\"2\",\"2\":\"<dbl [25]>\"},{\"1\":\"3\",\"2\":\"<dbl [25]>\"},{\"1\":\"4\",\"2\":\"<dbl [25]>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\\normalsize\n\n- Each row of our dataframe contains *all* of a bootstrap sample of 25 observations drawn with replacement from the attendances.\n\n\\normalsize\n\n## Sample means\n\n- Find the mean of each sample:\n\n\\footnotesize\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(sim = 1:4) %>% \n  rowwise() %>% \n  mutate(sample = list(sample(jays$attendance, replace = TRUE))) %>% \n  mutate(my_mean = mean(sample))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"sim\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"sample\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"my_mean\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"<dbl [25]>\",\"3\":\"28472.20\"},{\"1\":\"2\",\"2\":\"<dbl [25]>\",\"3\":\"28647.52\"},{\"1\":\"3\",\"2\":\"<dbl [25]>\",\"3\":\"23328.88\"},{\"1\":\"4\",\"2\":\"<dbl [25]>\",\"3\":\"24808.20\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\\normalsize\n\n- These are (four simulated values of) the bootstrapped sampling distribution of the sample mean.\n\n## Make a histogram of them\n\n- rather pointless here, but to get the idea:\n\n\\footnotesize\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(sim = 1:4) %>% \n  rowwise() %>% \n  mutate(sample = list(sample(jays$attendance, replace = TRUE))) %>% \n  mutate(my_mean = mean(sample)) %>% \n  ggplot(aes(x = my_mean)) + geom_histogram(bins = 3) -> g\n```\n:::\n\n\\normalsize\n\n## The (pointless) histogram\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng\n```\n\n::: {.cell-output-display}\n![](bootstrap_R_files/figure-revealjs/bootstrap-R-10-1.png){width=960}\n:::\n:::\n\n\n## Now do again with a decent number of bootstrap samples\n\n- say 1000, and put a decent number of bins on the histogram also:\n\n\\footnotesize\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(sim = 1:1000) %>% \n  rowwise() %>% \n  mutate(sample = list(sample(jays$attendance, replace = TRUE))) %>% \n  mutate(my_mean = mean(sample)) %>% \n  ggplot(aes(x = my_mean)) + geom_histogram(bins = 10) -> g\n```\n:::\n\n\\normalsize\n\n## The (better) histogram\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng\n```\n\n::: {.cell-output-display}\n![](bootstrap_R_files/figure-revealjs/bootstrap-R-12-1.png){width=960}\n:::\n:::\n\n\n## Comments\n\n- This is very close to normal\n- The bootstrap says that the sampling distribution of the sample mean is close to normal, even though the distribution of the data is not\n- A sample size of 25 is big enough to overcome the skewness that we saw\n- This is the Central Limit Theorem in practice\n- It is surprisingly powerful.\n- Thus, the $t$-test is actually perfectly good here.\n\n## Comments on the code 1/2\n\n- You might have been wondering about this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(sim = 1:4) %>% \n  rowwise() %>% \n  mutate(sample = list(sample(jays$attendance, replace = TRUE)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"sim\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"sample\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"<dbl [25]>\"},{\"1\":\"2\",\"2\":\"<dbl [25]>\"},{\"1\":\"3\",\"2\":\"<dbl [25]>\"},{\"1\":\"4\",\"2\":\"<dbl [25]>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Comments on the code 2/2\n\n\n- how did we squeeze all 25 sample values into one cell?\n  - sample is a so-called \"list-column\" that can contain anything.\n- why did we have to put `list()` around the `sample()`?\n  - because `sample` produces a collection of numbers, not just a single one\n  - the `list()` signals this: \"make a list-column of samples\".\n  \n  \n## Two samples\n\n- Assumption: *both* samples are from a normal distribution.\n- In practice, each sample is \"normal enough\" given its sample size, since Central Limit Theorem will help.\n- Use bootstrap on each group independently, as above.\n\n## Kids learning to read\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(kids, aes(x=group, y=score)) + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](bootstrap_R_files/figure-revealjs/bootstrap-R-15-1.png){width=960}\n:::\n:::\n\n\n\n## Getting just the control group \n\n- Use `filter` to select rows where something is true:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkids %>% filter(group==\"c\") -> controls\ncontrols\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"group\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"score\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"c\",\"2\":\"42\"},{\"1\":\"c\",\"2\":\"33\"},{\"1\":\"c\",\"2\":\"46\"},{\"1\":\"c\",\"2\":\"37\"},{\"1\":\"c\",\"2\":\"43\"},{\"1\":\"c\",\"2\":\"41\"},{\"1\":\"c\",\"2\":\"10\"},{\"1\":\"c\",\"2\":\"42\"},{\"1\":\"c\",\"2\":\"55\"},{\"1\":\"c\",\"2\":\"19\"},{\"1\":\"c\",\"2\":\"17\"},{\"1\":\"c\",\"2\":\"55\"},{\"1\":\"c\",\"2\":\"26\"},{\"1\":\"c\",\"2\":\"54\"},{\"1\":\"c\",\"2\":\"60\"},{\"1\":\"c\",\"2\":\"28\"},{\"1\":\"c\",\"2\":\"62\"},{\"1\":\"c\",\"2\":\"20\"},{\"1\":\"c\",\"2\":\"53\"},{\"1\":\"c\",\"2\":\"48\"},{\"1\":\"c\",\"2\":\"37\"},{\"1\":\"c\",\"2\":\"85\"},{\"1\":\"c\",\"2\":\"42\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Bootstrap these\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(sim = 1:1000) %>% \n  rowwise() %>% \n  mutate(sample = list(sample(controls$score, replace = TRUE))) %>% \n  mutate(my_mean = mean(sample)) %>% \n  ggplot(aes(x = my_mean)) + geom_histogram(bins = 10) \n```\n\n::: {.cell-output-display}\n![](bootstrap_R_files/figure-revealjs/bootstrap-R-17-1.png){width=960}\n:::\n:::\n\n\n## ... and the treatment group:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkids %>% filter(group==\"t\") -> treats\ntibble(sim = 1:1000) %>% \n  rowwise() %>% \n  mutate(sample = list(sample(treats$score, replace = TRUE))) %>% \n  mutate(my_mean = mean(sample)) %>% \n  ggplot(aes(x = my_mean)) + geom_histogram(bins = 10) \n```\n\n::: {.cell-output-display}\n![](bootstrap_R_files/figure-revealjs/bootstrap-R-19-1.png){width=960}\n:::\n:::\n\n\n## Comments\n\n- sampling distributions of sample means both look pretty normal\n- as we thought, no problems with our two-sample $t$ at all.\n\n",
    "supporting": [
      "bootstrap_R_files/figure-revealjs"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"bootstrap_R_files/libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"bootstrap_R_files/libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}